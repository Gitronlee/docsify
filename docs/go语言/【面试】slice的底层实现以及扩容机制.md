# 切片的底层实现

<font color=red>Go数组是值类型</font>，因此在赋值和函数传参时，会复制整个数组数据，可能由此带来大量的内存消耗。可以考虑传数组指针的方式，但是<font color=red>传指针会有一个弊端</font>：万一原指针被改变，那么函数里的指针也会随之更改。
应对这种场景改为传递切片是不错的方式，由于切片的数据结构，可以避免消耗大量内存。但并不是所有的场景，切片代替数组都是一个好选择：因为切片底层数组可能会在堆上分配内存，而小数组在栈上拷贝的消耗可能小于make的消耗。

## 一、为什么说传参切片能避免消耗大量内存？

切片的数据结构定义如下：其工作机制类似于对数组指针的一种封装。

```go
type slice struct {
    array unsafe.Pointer//指针，指向底层数组
    len   int//当前切片的长度
    cap   int//当前切片的容量
}
```

也就是说，<font color=red>传参时，切片的值拷贝只是一个指针+两个数字而已</font>。

## 二、创建切片形式的差异

- ```slice:=make([]int,4,6)```用 make 函数创建的一个 len = 4， cap = 6 的切片。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。当切片发生逃逸或者非常大时，运行时需要 runtime.makeslice 在堆上初始化切片，如果当前的切片不会发生逃逸并且切片非常小的时候，make([]int, 3, 4) 会被直接转换成如下所示的代码：
  
  ```go
  var arr [4]int
  n := arr[:3]
  ```
  
  上述代码会初始化数组并通过下标 [:3] 得到数组对应的切片，这两部分操作都会在编译阶段完成，编译器会在栈上或者静态存储区创建数组。
- ```slice:=[]int(10,20,30,40,50,60)```用字面量初始化一个切片时，len、cap根据给的字面量决定。
- ```slice:=array[2:5:5]```用已存在的数组获取一个切片时，```[)```前闭后开的截取，len和cap分别由后两个结束索引与起始索引的差值。
  
  ```go
  array := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  slice := array[2:5:5]
  //[3 4 5] 3 3
  fmt.Println(slice, len(slice), cap(slice))
  ```
- ```var slice []int```只声明一个切片时是<font color=green>nil切片，其指针指向nil</font>。
- ```slice:=make([]int, 0)``` 和 ```slice := []int{}```为<font color=green>空切片，其指针指向一个内存地址，但地址未分配相应的空间</font>，即底层元素包含0个元素。

## 三、切片扩容的策略是什么

- 如果切片的<font color=orange>容量小于 1024 个元素，就翻倍增加容量</font>。一旦元素个数<font color=orange>超过 1024 个元素</font>，那么<font color=orange>增长因子就变成 1.25</font> ，即每次增加原来容量的四分之一。
- 若原数组还有容量可以扩容，执行 append() 操作以后，会在原数组上直接操作，所以这种扩容以后的数组指针还是指向原来的数组。所以<font color=orange>如果原数组上有多个切片，那么这些切片都会被影响</font>！无意间就产生了莫名的 bug！
- 原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。

## 四、切片的拷贝

- copy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。
- 如果用 <font color=blue>range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝</font>。所以每次打印 Value 的地址都不变。且由于 Value 是值拷贝的，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。

