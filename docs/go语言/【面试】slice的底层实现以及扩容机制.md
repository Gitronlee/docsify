# Slice的底层实现

我们都知道<font color=red>Go数组是值类型</font>，因此赋值和函数传参都会复制整个数组数据，可能由此带来大量的内存消耗。因此可以考虑传递数组的指针的方式，但是<font color=red>传指针会有一个弊端</font>：万一原指针被改变，那么函数里的指针也会随之更改。
应对这种场景改为传递切片是不错的方式，由于切片的数据结构，可以避免消耗大量内存。
其实，并非所有的场景下用切片代替数组都是一个好选择：因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗不见得大于make的消耗。

## 一、为什么说传参切片能避免消耗大量内存呢？
看切片的数据结构定义如下：其工作机制类似于对数组指针的一种封装。
```go
type slice struct {
    array unsafe.Pointer//指针，指向底层数组
    len   int//当前切片的长度
    cap   int//当前切片的容量
}
```
也就是说，<font color=red>传参时，切片的值拷贝只是一个指针+两个数字而已</font>。
## 二、两种创建切片形式的差异。
你知道用不同的创建（初始化）切片操作有什么区别么？
- ```slice:=make([]int,4,6)```用 make 函数创建的一个 len = 4， cap = 6 的切片。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。
- ```slice:=[]int(10,20,30,40,50,60)```用字面量初始化一个切片时，len、cap时根据给的字面量决定的。
- ```slice:=array[2:5:5]```用已存在的数组获取一个切片时，```[)```前闭后开的截取，len和cap分别由后两个结束索引与起始索引的差值。
- ```var slice []int```只声明一个切片时是<font color=green>nil切片，其指针指向nil</font>。
- ```slice:=make([]int, 0)``` 和 ```slice := []int{}```若初始化了，则为<font color=green>空切片，其指针指向一个内存地址，但地址未分配相应的空间</font>，即底层元素包含0个元素。
## 三、切片扩容的策略是什么
- 如果切片的<font color=orange>容量小于 1024 个元素，就翻倍增加容量</font>。一旦元素个数<font color=orange>超过 1024 个元素</font>，那么<font color=orange>增长因子就变成 1.25</font> ，即每次增加原来容量的四分之一。
- 若原数组还有容量可以扩容，执行 append() 操作以后，会在原数组上直接操作，所以这种扩容以后的数组指针还是指向原来的数组。所以<font color=orange>如果原数组上有多个切片，那么这些切片都会被影响</font>！无意间就产生了莫名的 bug！
- 原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。
## 四、切片的拷贝
- copy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。
- 如果用 <font color=blue>range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝</font>。所以每次打印 Value 的地址都不变。且由于 Value 是值拷贝的，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。